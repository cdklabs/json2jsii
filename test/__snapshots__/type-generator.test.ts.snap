// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`camel casing 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#CamelCase1
   */
  readonly camelCase1?: string;

  /**
   * @schema fqn.of.TestType#Camel_Case2
   */
  readonly camelCase2?: string;

  /**
   * @schema fqn.of.TestType#camel_case_3
   */
  readonly camelCase3?: string;

  /**
   * @schema fqn.of.TestType#CAMEL_CASE_4
   */
  readonly camelCase4?: string;

  /**
   * @schema fqn.of.TestType#camel-case-5
   */
  readonly camelCase5?: string;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'CamelCase1': obj.camelCase1,
    'Camel_Case2': obj.camelCase2,
    'camel_case_3': obj.camelCase3,
    'CAMEL_CASE_4': obj.camelCase4,
    'camel-case-5': obj.camelCase5,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`custom ref normalization 1`] = `
"/**
 * @schema Bar
 */
export interface Bar {
  /**
   * @schema Bar#prop
   */
  readonly prop?: V1beta1Foo;

}

/**
 * Converts an object of type 'Bar' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Bar(obj: Bar | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prop': toJson_V1beta1Foo(obj.prop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema io.k8s.v1beta1.Foo
 */
export interface V1beta1Foo {
  /**
   * @schema io.k8s.v1beta1.Foo#props
   */
  readonly props?: number;

}

/**
 * Converts an object of type 'V1beta1Foo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_V1beta1Foo(obj: V1beta1Foo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'props': obj.props,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`documentation "*/" is is escaped 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * hello _/world
   *
   * @schema fqn.of.TestType#field
   */
  readonly field?: string;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`documentation does not render if not defined 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#field
   */
  readonly field?: boolean;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`documentation renders based on description 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * hello, description
   *
   * @schema fqn.of.TestType#field
   */
  readonly field?: string;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`enums renders a typescript enum 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * description of first enum
   *
   * @schema fqn.of.TestType#firstEnum
   */
  readonly firstEnum: FqnOfTestTypeFirstEnum;

  /**
   * @schema fqn.of.TestType#child
   */
  readonly child?: FqnOfTestTypeChild;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'firstEnum': obj.firstEnum,
    'child': toJson_FqnOfTestTypeChild(obj.child),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * description of first enum
 *
 * @schema FqnOfTestTypeFirstEnum
 */
export enum FqnOfTestTypeFirstEnum {
  /** value1 */
  VALUE1 = 'value1',
  /** value2 */
  VALUE2 = 'value2',
  /** value-of-three */
  VALUE_OF_THREE = 'value-of-three',
  /** valueOfFour */
  VALUE_OF_FOUR = 'valueOfFour',
}

/**
 * @schema FqnOfTestTypeChild
 */
export interface FqnOfTestTypeChild {
  /**
   * description of second enum
   *
   * @schema FqnOfTestTypeChild#secondEnum
   */
  readonly secondEnum?: FqnOfTestTypeChildSecondEnum;

}

/**
 * Converts an object of type 'FqnOfTestTypeChild' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_FqnOfTestTypeChild(obj: FqnOfTestTypeChild | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secondEnum': obj.secondEnum,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * description of second enum
 *
 * @schema FqnOfTestTypeChildSecondEnum
 */
export enum FqnOfTestTypeChildSecondEnum {
  /** hey */
  HEY = 'hey',
  /** enum values can be crazy */
  ENUM_VALUES_CAN_BE_CRAZY = 'enum values can be crazy',
  /** yes>>123 */
  YES_123 = 'yes>>123',
}
"
`;

exports[`enums uses non-symbolic values 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * The SLO time window options. Allowed enum values: 7d,30d,90d
   *
   * @schema fqn.of.TestType#Timeframe
   */
  readonly timeframe?: FqnOfTestTypeTimeframe;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Timeframe': obj.timeframe,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * The SLO time window options. Allowed enum values: 7d,30d,90d
 *
 * @schema FqnOfTestTypeTimeframe
 */
export enum FqnOfTestTypeTimeframe {
  /** 7d */
  VALUE_7D = '7d',
  /** 30d */
  VALUE_30D = '30d',
  /** 90d */
  VALUE_90D = '90d',
}
"
`;

exports[`enums without type implies "string" 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#Color
   */
  readonly color?: FqnOfTestTypeColor;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'Color': obj.color,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema FqnOfTestTypeColor
 */
export enum FqnOfTestTypeColor {
  /** red */
  RED = 'red',
  /** green */
  GREEN = 'green',
  /** blue */
  BLUE = 'blue',
}
"
`;

exports[`if "toJson" is disabled, toJson functions are not generated 1`] = `
"/**
 * @schema Foo
 */
export interface Foo {
  /**
   * @schema Foo#bar
   */
  readonly bar?: string;

}
"
`;

exports[`primitives 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#stringValue
   */
  readonly stringValue?: string;

  /**
   * @schema fqn.of.TestType#booleanValue
   */
  readonly booleanValue?: boolean;

  /**
   * @schema fqn.of.TestType#dateValue
   */
  readonly dateValue?: Date;

  /**
   * @schema fqn.of.TestType#dateValueImplicitType
   */
  readonly dateValueImplicitType?: Date;

  /**
   * @schema fqn.of.TestType#anyValue
   */
  readonly anyValue?: any;

  /**
   * @schema fqn.of.TestType#nullValue
   */
  readonly nullValue?: any;

  /**
   * @schema fqn.of.TestType#numberValue
   */
  readonly numberValue?: number;

  /**
   * @schema fqn.of.TestType#integerValue
   */
  readonly integerValue?: number;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stringValue': obj.stringValue,
    'booleanValue': obj.booleanValue,
    'dateValue': obj.dateValue?.toISOString(),
    'dateValueImplicitType': obj.dateValueImplicitType?.toISOString(),
    'anyValue': obj.anyValue,
    'nullValue': obj.nullValue,
    'numberValue': obj.numberValue,
    'integerValue': obj.integerValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`shared namespace references 1`] = `
"/**
 * @schema Bar1
 */
export interface Bar1 {
  /**
   * @schema Bar1#prop
   */
  readonly prop?: IoK8Sv1Beta1Foo;

}

/**
 * Converts an object of type 'Bar1' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Bar1(obj: Bar1 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prop': toJson_IoK8Sv1Beta1Foo(obj.prop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Bar2
 */
export interface Bar2 {
  /**
   * @schema Bar2#prop
   */
  readonly prop?: IoK8Sv1Foo;

}

/**
 * Converts an object of type 'Bar2' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Bar2(obj: Bar2 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'prop': toJson_IoK8Sv1Foo(obj.prop),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema io.k8s.v1beta1.Foo
 */
export interface IoK8Sv1Beta1Foo {
  /**
   * @schema io.k8s.v1beta1.Foo#props
   */
  readonly props?: number;

}

/**
 * Converts an object of type 'IoK8Sv1Beta1Foo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IoK8Sv1Beta1Foo(obj: IoK8Sv1Beta1Foo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'props': obj.props,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema io.k8s.v1.Foo
 */
export interface IoK8Sv1Foo {
  /**
   * @schema io.k8s.v1.Foo#props
   */
  readonly props?: string;

}

/**
 * Converts an object of type 'IoK8Sv1Foo' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_IoK8Sv1Foo(obj: IoK8Sv1Foo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'props': obj.props,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs array of structs is considered optional 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#shouldBeRequired
   */
  readonly shouldBeRequired?: ItemType;

  /**
   * @schema fqn.of.TestType#mapShouldBeOptional
   */
  readonly mapShouldBeOptional?: { [key: string]: ItemType };

  /**
   * @schema fqn.of.TestType#arrayShouldBeOptional
   */
  readonly arrayShouldBeOptional?: ItemType[];

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'shouldBeRequired': toJson_ItemType(obj.shouldBeRequired),
    'mapShouldBeOptional': ((obj.mapShouldBeOptional) === undefined) ? undefined : (Object.entries(obj.mapShouldBeOptional).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_ItemType(i[1]) }), {})),
    'arrayShouldBeOptional': obj.arrayShouldBeOptional?.map(y => toJson_ItemType(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ItemType
 */
export interface ItemType {
  /**
   * @schema ItemType#requiredField
   */
  readonly requiredField: string;

}

/**
 * Converts an object of type 'ItemType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ItemType(obj: ItemType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requiredField': obj.requiredField,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs has a field that references another struct (with required fields) 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#other
   */
  readonly other?: Other;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'other': toJson_Other(obj.other),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema Other
 */
export interface Other {
  /**
   * @schema Other#stringValue
   */
  readonly stringValue: string;

}

/**
 * Converts an object of type 'Other' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_Other(obj: Other | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stringValue': obj.stringValue,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs has primitive types and collections of primitive types 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#stringValue
   */
  readonly stringValue?: string;

  /**
   * @schema fqn.of.TestType#boolValue
   */
  readonly boolValue?: boolean;

  /**
   * @schema fqn.of.TestType#numberValue
   */
  readonly numberValue?: number;

  /**
   * @schema fqn.of.TestType#integerValue
   */
  readonly integerValue?: number;

  /**
   * @schema fqn.of.TestType#arrayOfString
   */
  readonly arrayOfString?: string[];

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'stringValue': obj.stringValue,
    'boolValue': obj.boolValue,
    'numberValue': obj.numberValue,
    'integerValue': obj.integerValue,
    'arrayOfString': obj.arrayOfString?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs if we have "properties" and "type" is omitted, it is considered a struct 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#foo
   */
  readonly foo?: string;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'foo': obj.foo,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs includes required fields 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
   *
   * @default 0 (pod will be considered available as soon as it is ready)
   * @schema fqn.of.TestType#minReadySeconds
   */
  readonly minReadySeconds: number;

  /**
   * Indicates that the deployment is paused.
   *
   * @schema fqn.of.TestType#paused
   */
  readonly paused?: boolean;

  /**
   * The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
   *
   * @default 600s.
   * @schema fqn.of.TestType#progressDeadlineSeconds
   */
  readonly progressDeadlineSeconds?: number;

  /**
   * Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
   *
   * @default 1.
   * @schema fqn.of.TestType#replicas
   */
  readonly replicas?: number;

  /**
   * The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 10.
   *
   * @default 10.
   * @schema fqn.of.TestType#revisionHistoryLimit
   */
  readonly revisionHistoryLimit: number;

  /**
   * @schema fqn.of.TestType#NonCamelCaseRequired
   */
  readonly nonCamelCaseRequired: string;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'minReadySeconds': obj.minReadySeconds,
    'paused': obj.paused,
    'progressDeadlineSeconds': obj.progressDeadlineSeconds,
    'replicas': obj.replicas,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'NonCamelCaseRequired': obj.nonCamelCaseRequired,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`structs references itself 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export interface TestType {
  /**
   * @schema fqn.of.TestType#entrypoint
   */
  readonly entrypoint?: MyType;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'entrypoint': toJson_MyType(obj.entrypoint),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema MyType
 */
export interface MyType {
  /**
   * @schema MyType#self
   */
  readonly self?: MyType;

}

/**
 * Converts an object of type 'MyType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_MyType(obj: MyType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'self': toJson_MyType(obj.self),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`type aliases alias to a custom type 1`] = `
"// this is NewType

/**
 * @schema TypeB
 */
export interface TypeB {
  /**
   * @schema TypeB#refToTypeA
   */
  readonly refToTypeA?: NewType;

}

/**
 * Converts an object of type 'TypeB' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TypeB(obj: TypeB | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'refToTypeA': obj.refToTypeA,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`type aliases alias to a definition 1`] = `
"/**
 * @schema TypeA
 */
export interface TypeA {
  /**
   * @schema TypeA#ref
   */
  readonly ref?: TypeC;

}

/**
 * Converts an object of type 'TypeA' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TypeA(obj: TypeA | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': toJson_TypeC(obj.ref),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TypeC
 */
export interface TypeC {
  /**
   * @schema TypeC#field
   */
  readonly field?: string;

}

/**
 * Converts an object of type 'TypeC' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TypeC(obj: TypeC | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'field': obj.field,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`unions constraints are ignored for objects 1`] = `
"/**
 * @schema TestType
 */
export interface TestType {
  /**
   * Fault injection policy to apply on HTTP traffic at
   * the client side.
   *
   * @schema TestType#fault
   */
  readonly fault?: TestTypeFault;

}

/**
 * Converts an object of type 'TestType' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestType(obj: TestType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fault': toJson_TestTypeFault(obj.fault),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Fault injection policy to apply on HTTP traffic at
 * the client side.
 *
 * @schema TestTypeFault
 */
export interface TestTypeFault {
  /**
   * @schema TestTypeFault#delay
   */
  readonly delay?: TestTypeFaultDelay;

}

/**
 * Converts an object of type 'TestTypeFault' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestTypeFault(obj: TestTypeFault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'delay': toJson_TestTypeFaultDelay(obj.delay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema TestTypeFaultDelay
 */
export interface TestTypeFaultDelay {
  /**
   * @schema TestTypeFaultDelay#exponentialDelay
   */
  readonly exponentialDelay?: string;

  /**
   * Add a fixed delay before forwarding the request.
   *
   * @schema TestTypeFaultDelay#fixedDelay
   */
  readonly fixedDelay?: string;

  /**
   * Percentage of requests on which the delay
   * will be injected (0-100).
   *
   * @schema TestTypeFaultDelay#percent
   */
  readonly percent?: number;

  /**
   * Percentage of requests on which the delay
   * will be injected.
   *
   * @schema TestTypeFaultDelay#percentage
   */
  readonly percentage?: TestTypeFaultDelayPercentage;

}

/**
 * Converts an object of type 'TestTypeFaultDelay' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestTypeFaultDelay(obj: TestTypeFaultDelay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'exponentialDelay': obj.exponentialDelay,
    'fixedDelay': obj.fixedDelay,
    'percent': obj.percent,
    'percentage': toJson_TestTypeFaultDelayPercentage(obj.percentage),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Percentage of requests on which the delay
 * will be injected.
 *
 * @schema TestTypeFaultDelayPercentage
 */
export interface TestTypeFaultDelayPercentage {
  /**
   * @schema TestTypeFaultDelayPercentage#value
   */
  readonly value?: number;

}

/**
 * Converts an object of type 'TestTypeFaultDelayPercentage' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TestTypeFaultDelayPercentage(obj: TestTypeFaultDelayPercentage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */
"
`;

exports[`unions include primitives 1`] = `
"/**
 * @schema fqn.of.TestType
 */
export class TestType {
  public static fromString(value: string): TestType {
    return new TestType(value);
  }
  public static fromNumber(value: number): TestType {
    return new TestType(value);
  }
  private constructor(public readonly value: string | number) {
  }
}
"
`;
